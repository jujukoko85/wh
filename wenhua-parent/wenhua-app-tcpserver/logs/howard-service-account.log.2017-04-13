[INFO ][20170413 01:01:18,968][TcpServer:12] Wenhua Mesage Tcp Server starting...
[INFO ][20170413 01:01:19,033][AbstractApplicationContext:582] Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@5baa0b72: startup date [Thu Apr 13 01:01:19 CST 2017]; root of context hierarchy
[INFO ][20170413 01:01:19,088][XmlBeanDefinitionReader:317] Loading XML bean definitions from class path resource [spring-context.xml]
[INFO ][20170413 22:36:16,600][TcpServer:56] Wenhua Mesage Tcp Server starting...
[INFO ][20170413 22:36:16,759][AbstractApplicationContext:582] Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@1d982af8: startup date [Thu Apr 13 22:36:16 CST 2017]; root of context hierarchy
[INFO ][20170413 22:36:16,837][XmlBeanDefinitionReader:317] Loading XML bean definitions from class path resource [spring-context.xml]
[WARN ][20170413 22:36:17,226][AbstractApplicationContext:550] Exception encountered during context initialization - cancelling refresh attempt: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'tcpServer' defined in class path resource [spring-context.xml]: Cannot resolve reference to bean 'tcpServerInitializer' while setting bean property 'initializer'; nested exception is org.springframework.beans.factory.CannotLoadBeanClassException: Cannot find class [com.netty.HelloServerInitializer] for bean with name 'tcpServerInitializer' defined in class path resource [spring-context.xml]; nested exception is java.lang.ClassNotFoundException: com.netty.HelloServerInitializer
[INFO ][20170413 22:36:49,386][TcpServer:56] Wenhua Mesage Tcp Server starting...
[INFO ][20170413 22:36:49,447][AbstractApplicationContext:582] Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@571cb4a6: startup date [Thu Apr 13 22:36:49 CST 2017]; root of context hierarchy
[INFO ][20170413 22:36:49,507][XmlBeanDefinitionReader:317] Loading XML bean definitions from class path resource [spring-context.xml]
[WARN ][20170413 22:36:49,931][AbstractApplicationContext:550] Exception encountered during context initialization - cancelling refresh attempt: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'tcpServer' defined in class path resource [spring-context.xml]: Cannot resolve reference to bean 'tcpServerInitializer' while setting bean property 'initializer'; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'tcpServerInitializer' defined in class path resource [spring-context.xml]: Error setting property values; nested exception is org.springframework.beans.NotWritablePropertyException: Invalid property 'channelHandlerWenhuaMsg' of bean class [com.wenhua.server.TcpServerInitializer]: Bean property 'channelHandlerWenhuaMsg' is not writable or has an invalid setter method. Does the parameter type of the setter match the return type of the getter?
[INFO ][20170413 22:37:44,737][TcpServer:56] Wenhua Mesage Tcp Server starting...
[INFO ][20170413 22:37:44,799][AbstractApplicationContext:582] Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@712d0ef5: startup date [Thu Apr 13 22:37:44 CST 2017]; root of context hierarchy
[INFO ][20170413 22:37:44,859][XmlBeanDefinitionReader:317] Loading XML bean definitions from class path resource [spring-context.xml]
[WARN ][20170413 22:37:45,121][AbstractApplicationContext:550] Exception encountered during context initialization - cancelling refresh attempt: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'tcpServer' defined in class path resource [spring-context.xml]: Cannot resolve reference to bean 'tcpServerInitializer' while setting bean property 'initializer'; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'tcpServerInitializer' defined in class path resource [spring-context.xml]: Error setting property values; nested exception is org.springframework.beans.NotWritablePropertyException: Invalid property 'channelHandlerWenhuaMsg' of bean class [com.wenhua.server.TcpServerInitializer]: Bean property 'channelHandlerWenhuaMsg' is not writable or has an invalid setter method. Does the parameter type of the setter match the return type of the getter?
[INFO ][20170413 22:38:37,433][TcpServer:56] Wenhua Mesage Tcp Server starting...
[INFO ][20170413 22:38:37,524][AbstractApplicationContext:582] Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@1d982af8: startup date [Thu Apr 13 22:38:37 CST 2017]; root of context hierarchy
[INFO ][20170413 22:38:37,605][XmlBeanDefinitionReader:317] Loading XML bean definitions from class path resource [spring-context.xml]
[INFO ][20170413 22:38:37,961][TcpServer:71] ##TcpServer begin start, port is [10089]
[INFO ][20170413 22:38:37,961][TcpServer:25] Server start...
[INFO ][20170413 22:39:00,497][TcpServer:56] Wenhua Mesage Tcp Server starting...
[INFO ][20170413 22:39:00,558][AbstractApplicationContext:582] Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@207fa3f6: startup date [Thu Apr 13 22:39:00 CST 2017]; root of context hierarchy
[INFO ][20170413 22:39:00,619][XmlBeanDefinitionReader:317] Loading XML bean definitions from class path resource [spring-context.xml]
[INFO ][20170413 22:39:00,877][TcpServer:71] ##TcpServer begin start, port is [10089]
[INFO ][20170413 22:39:00,877][TcpServer:25] Server start...
[INFO ][20170413 23:00:56,994][TcpServer:56] Wenhua Mesage Tcp Server starting...
[INFO ][20170413 23:00:57,070][AbstractApplicationContext:582] Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@1d982af8: startup date [Thu Apr 13 23:00:57 CST 2017]; root of context hierarchy
[INFO ][20170413 23:00:57,152][XmlBeanDefinitionReader:317] Loading XML bean definitions from class path resource [spring-context.xml]
[INFO ][20170413 23:00:57,417][TcpServer:71] ##TcpServer begin start, port is [10089]
[INFO ][20170413 23:00:57,417][TcpServer:25] Server start...
[INFO ][20170413 23:02:27,752][ChannelHandlerWenhuaMsgClient:19] MessageProto channelActive
[ERROR][20170413 23:02:44,580][ChannelHandlerWenhuaMsg:48] ##exceptionCaught
java.io.IOException: 远程主机强迫关闭了一个现有的连接。
	at sun.nio.ch.SocketDispatcher.read0(Native Method)
	at sun.nio.ch.SocketDispatcher.read(SocketDispatcher.java:43)
	at sun.nio.ch.IOUtil.readIntoNativeBuffer(IOUtil.java:223)
	at sun.nio.ch.IOUtil.read(IOUtil.java:192)
	at sun.nio.ch.SocketChannelImpl.read(SocketChannelImpl.java:384)
	at io.netty.buffer.PooledUnsafeDirectByteBuf.setBytes(PooledUnsafeDirectByteBuf.java:288)
	at io.netty.buffer.AbstractByteBuf.writeBytes(AbstractByteBuf.java:1100)
	at io.netty.channel.socket.nio.NioSocketChannel.doReadBytes(NioSocketChannel.java:372)
	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:123)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:624)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:559)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:476)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:438)
	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:858)
	at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:144)
	at java.lang.Thread.run(Thread.java:745)
[WARN ][20170413 23:02:44,585][Slf4JLogger:151] An exceptionCaught() event was fired, and it reached at the tail of the pipeline. It usually means the last handler in the pipeline did not handle the exception.
java.io.IOException: 远程主机强迫关闭了一个现有的连接。
	at sun.nio.ch.SocketDispatcher.read0(Native Method)
	at sun.nio.ch.SocketDispatcher.read(SocketDispatcher.java:43)
	at sun.nio.ch.IOUtil.readIntoNativeBuffer(IOUtil.java:223)
	at sun.nio.ch.IOUtil.read(IOUtil.java:192)
	at sun.nio.ch.SocketChannelImpl.read(SocketChannelImpl.java:384)
	at io.netty.buffer.PooledUnsafeDirectByteBuf.setBytes(PooledUnsafeDirectByteBuf.java:288)
	at io.netty.buffer.AbstractByteBuf.writeBytes(AbstractByteBuf.java:1100)
	at io.netty.channel.socket.nio.NioSocketChannel.doReadBytes(NioSocketChannel.java:372)
	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:123)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:624)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:559)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:476)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:438)
	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:858)
	at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:144)
	at java.lang.Thread.run(Thread.java:745)
[INFO ][20170413 23:02:57,829][ChannelHandlerWenhuaMsgClient:19] MessageProto channelActive
[WARN ][20170413 23:02:57,887][Slf4JLogger:151] Failed to initialize a channel. Closing: [id: 0x1e5a681c, L:/127.0.0.1:10089 - R:/127.0.0.1:50493]
io.netty.channel.ChannelPipelineException: com.wenhua.server.ChannelHandlerWenhuaMsg is not a @Sharable handler, so can't be added or removed multiple times.
	at io.netty.channel.DefaultChannelPipeline.checkMultiplicity(DefaultChannelPipeline.java:588)
	at io.netty.channel.DefaultChannelPipeline.addLast(DefaultChannelPipeline.java:199)
	at io.netty.channel.DefaultChannelPipeline.addLast(DefaultChannelPipeline.java:392)
	at io.netty.channel.DefaultChannelPipeline.addLast(DefaultChannelPipeline.java:379)
	at com.wenhua.server.TcpServerInitializer.initChannel(TcpServerInitializer.java:28)
	at com.wenhua.server.TcpServerInitializer.initChannel(TcpServerInitializer.java:1)
	at io.netty.channel.ChannelInitializer.initChannel(ChannelInitializer.java:113)
	at io.netty.channel.ChannelInitializer.handlerAdded(ChannelInitializer.java:105)
	at io.netty.channel.DefaultChannelPipeline.callHandlerAdded0(DefaultChannelPipeline.java:597)
	at io.netty.channel.DefaultChannelPipeline.access$000(DefaultChannelPipeline.java:44)
	at io.netty.channel.DefaultChannelPipeline$PendingHandlerAddedTask.execute(DefaultChannelPipeline.java:1387)
	at io.netty.channel.DefaultChannelPipeline.callHandlerAddedForAllHandlers(DefaultChannelPipeline.java:1122)
	at io.netty.channel.DefaultChannelPipeline.invokeHandlerAddedIfNeeded(DefaultChannelPipeline.java:647)
	at io.netty.channel.AbstractChannel$AbstractUnsafe.register0(AbstractChannel.java:506)
	at io.netty.channel.AbstractChannel$AbstractUnsafe.access$200(AbstractChannel.java:419)
	at io.netty.channel.AbstractChannel$AbstractUnsafe$1.run(AbstractChannel.java:478)
	at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:163)
	at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:403)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:442)
	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:858)
	at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:144)
	at java.lang.Thread.run(Thread.java:745)
[INFO ][20170413 23:03:57,911][TcpServer:56] Wenhua Mesage Tcp Server starting...
[INFO ][20170413 23:03:57,978][AbstractApplicationContext:582] Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@453130df: startup date [Thu Apr 13 23:03:57 CST 2017]; root of context hierarchy
[INFO ][20170413 23:03:58,034][XmlBeanDefinitionReader:317] Loading XML bean definitions from class path resource [spring-context.xml]
[INFO ][20170413 23:03:58,334][TcpServer:71] ##TcpServer begin start, port is [10089]
[INFO ][20170413 23:03:58,335][TcpServer:25] Server start...
[INFO ][20170413 23:04:06,339][ChannelHandlerWenhuaMsgClient:19] MessageProto channelActive
[INFO ][20170413 23:04:26,329][TcpServer:56] Wenhua Mesage Tcp Server starting...
[INFO ][20170413 23:04:26,387][AbstractApplicationContext:582] Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@453130df: startup date [Thu Apr 13 23:04:26 CST 2017]; root of context hierarchy
[INFO ][20170413 23:04:26,442][XmlBeanDefinitionReader:317] Loading XML bean definitions from class path resource [spring-context.xml]
[INFO ][20170413 23:04:26,697][TcpServer:71] ##TcpServer begin start, port is [10089]
[INFO ][20170413 23:04:26,697][TcpServer:25] Server start...
[INFO ][20170413 23:04:33,346][ChannelHandlerWenhuaMsgClient:19] MessageProto channelActive
[INFO ][20170413 23:06:34,249][ChannelHandlerWenhuaMsgClient:19] MessageProto channelActive
[ERROR][20170413 23:06:43,723][ChannelHandlerWenhuaMsg:50] ##exceptionCaught
java.io.IOException: 远程主机强迫关闭了一个现有的连接。
	at sun.nio.ch.SocketDispatcher.read0(Native Method)
	at sun.nio.ch.SocketDispatcher.read(SocketDispatcher.java:43)
	at sun.nio.ch.IOUtil.readIntoNativeBuffer(IOUtil.java:223)
	at sun.nio.ch.IOUtil.read(IOUtil.java:192)
	at sun.nio.ch.SocketChannelImpl.read(SocketChannelImpl.java:384)
	at io.netty.buffer.PooledUnsafeDirectByteBuf.setBytes(PooledUnsafeDirectByteBuf.java:288)
	at io.netty.buffer.AbstractByteBuf.writeBytes(AbstractByteBuf.java:1100)
	at io.netty.channel.socket.nio.NioSocketChannel.doReadBytes(NioSocketChannel.java:372)
	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:123)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:624)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:559)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:476)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:438)
	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:858)
	at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:144)
	at java.lang.Thread.run(Thread.java:745)
[WARN ][20170413 23:06:43,729][Slf4JLogger:151] An exceptionCaught() event was fired, and it reached at the tail of the pipeline. It usually means the last handler in the pipeline did not handle the exception.
java.io.IOException: 远程主机强迫关闭了一个现有的连接。
	at sun.nio.ch.SocketDispatcher.read0(Native Method)
	at sun.nio.ch.SocketDispatcher.read(SocketDispatcher.java:43)
	at sun.nio.ch.IOUtil.readIntoNativeBuffer(IOUtil.java:223)
	at sun.nio.ch.IOUtil.read(IOUtil.java:192)
	at sun.nio.ch.SocketChannelImpl.read(SocketChannelImpl.java:384)
	at io.netty.buffer.PooledUnsafeDirectByteBuf.setBytes(PooledUnsafeDirectByteBuf.java:288)
	at io.netty.buffer.AbstractByteBuf.writeBytes(AbstractByteBuf.java:1100)
	at io.netty.channel.socket.nio.NioSocketChannel.doReadBytes(NioSocketChannel.java:372)
	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:123)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:624)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:559)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:476)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:438)
	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:858)
	at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:144)
	at java.lang.Thread.run(Thread.java:745)
[INFO ][20170413 23:07:10,268][ChannelHandlerWenhuaMsgClient:19] MessageProto channelActive
[ERROR][20170413 23:07:26,710][ChannelHandlerWenhuaMsg:50] ##exceptionCaught
java.io.IOException: 远程主机强迫关闭了一个现有的连接。
	at sun.nio.ch.SocketDispatcher.read0(Native Method)
	at sun.nio.ch.SocketDispatcher.read(SocketDispatcher.java:43)
	at sun.nio.ch.IOUtil.readIntoNativeBuffer(IOUtil.java:223)
	at sun.nio.ch.IOUtil.read(IOUtil.java:192)
	at sun.nio.ch.SocketChannelImpl.read(SocketChannelImpl.java:384)
	at io.netty.buffer.PooledUnsafeDirectByteBuf.setBytes(PooledUnsafeDirectByteBuf.java:288)
	at io.netty.buffer.AbstractByteBuf.writeBytes(AbstractByteBuf.java:1100)
	at io.netty.channel.socket.nio.NioSocketChannel.doReadBytes(NioSocketChannel.java:372)
	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:123)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:624)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:559)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:476)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:438)
	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:858)
	at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:144)
	at java.lang.Thread.run(Thread.java:745)
[WARN ][20170413 23:07:26,711][Slf4JLogger:151] An exceptionCaught() event was fired, and it reached at the tail of the pipeline. It usually means the last handler in the pipeline did not handle the exception.
java.io.IOException: 远程主机强迫关闭了一个现有的连接。
	at sun.nio.ch.SocketDispatcher.read0(Native Method)
	at sun.nio.ch.SocketDispatcher.read(SocketDispatcher.java:43)
	at sun.nio.ch.IOUtil.readIntoNativeBuffer(IOUtil.java:223)
	at sun.nio.ch.IOUtil.read(IOUtil.java:192)
	at sun.nio.ch.SocketChannelImpl.read(SocketChannelImpl.java:384)
	at io.netty.buffer.PooledUnsafeDirectByteBuf.setBytes(PooledUnsafeDirectByteBuf.java:288)
	at io.netty.buffer.AbstractByteBuf.writeBytes(AbstractByteBuf.java:1100)
	at io.netty.channel.socket.nio.NioSocketChannel.doReadBytes(NioSocketChannel.java:372)
	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:123)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:624)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:559)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:476)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:438)
	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:858)
	at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:144)
	at java.lang.Thread.run(Thread.java:745)
[INFO ][20170413 23:13:45,592][TcpServer:56] Wenhua Mesage Tcp Server starting...
[INFO ][20170413 23:13:45,667][AbstractApplicationContext:582] Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@712d0ef5: startup date [Thu Apr 13 23:13:45 CST 2017]; root of context hierarchy
[INFO ][20170413 23:13:45,732][XmlBeanDefinitionReader:317] Loading XML bean definitions from class path resource [spring-context.xml]
[INFO ][20170413 23:13:46,033][TcpServer:71] ##TcpServer begin start, port is [10089]
[INFO ][20170413 23:13:46,033][TcpServer:25] Server start at [10089]...
[INFO ][20170413 23:14:16,349][TcpServer:56] Wenhua Mesage Tcp Server starting...
[INFO ][20170413 23:14:16,411][AbstractApplicationContext:582] Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@17056563: startup date [Thu Apr 13 23:14:16 CST 2017]; root of context hierarchy
[INFO ][20170413 23:14:16,470][XmlBeanDefinitionReader:317] Loading XML bean definitions from class path resource [spring-context.xml]
[INFO ][20170413 23:14:16,774][TcpServer:71] ##TcpServer begin start, port is [10089]
[INFO ][20170413 23:14:16,775][TcpServer:25] Server start at [10089]...
[INFO ][20170413 23:24:06,157][TcpServer:56] Wenhua Mesage Tcp Server starting...
[INFO ][20170413 23:24:06,221][AbstractApplicationContext:582] Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@207fa3f6: startup date [Thu Apr 13 23:24:06 CST 2017]; root of context hierarchy
[INFO ][20170413 23:24:06,280][XmlBeanDefinitionReader:317] Loading XML bean definitions from class path resource [spring-context.xml]
[INFO ][20170413 23:24:06,593][TcpServer:71] ##TcpServer begin start, port is [10089]
[INFO ][20170413 23:24:06,593][TcpServer:25] Server start at [10089]...
[INFO ][20170413 23:24:11,885][ChannelHandlerWenhuaMsgClient:19] MessageProto channelActive
[ERROR][20170413 23:24:22,465][ChannelHandlerWenhuaMsg:50] ##exceptionCaught
java.io.IOException: 远程主机强迫关闭了一个现有的连接。
	at sun.nio.ch.SocketDispatcher.read0(Native Method)
	at sun.nio.ch.SocketDispatcher.read(SocketDispatcher.java:43)
	at sun.nio.ch.IOUtil.readIntoNativeBuffer(IOUtil.java:223)
	at sun.nio.ch.IOUtil.read(IOUtil.java:192)
	at sun.nio.ch.SocketChannelImpl.read(SocketChannelImpl.java:384)
	at io.netty.buffer.PooledUnsafeDirectByteBuf.setBytes(PooledUnsafeDirectByteBuf.java:288)
	at io.netty.buffer.AbstractByteBuf.writeBytes(AbstractByteBuf.java:1100)
	at io.netty.channel.socket.nio.NioSocketChannel.doReadBytes(NioSocketChannel.java:372)
	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:123)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:624)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:559)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:476)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:438)
	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:858)
	at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:144)
	at java.lang.Thread.run(Thread.java:745)
[WARN ][20170413 23:24:22,473][Slf4JLogger:151] An exceptionCaught() event was fired, and it reached at the tail of the pipeline. It usually means the last handler in the pipeline did not handle the exception.
java.io.IOException: 远程主机强迫关闭了一个现有的连接。
	at sun.nio.ch.SocketDispatcher.read0(Native Method)
	at sun.nio.ch.SocketDispatcher.read(SocketDispatcher.java:43)
	at sun.nio.ch.IOUtil.readIntoNativeBuffer(IOUtil.java:223)
	at sun.nio.ch.IOUtil.read(IOUtil.java:192)
	at sun.nio.ch.SocketChannelImpl.read(SocketChannelImpl.java:384)
	at io.netty.buffer.PooledUnsafeDirectByteBuf.setBytes(PooledUnsafeDirectByteBuf.java:288)
	at io.netty.buffer.AbstractByteBuf.writeBytes(AbstractByteBuf.java:1100)
	at io.netty.channel.socket.nio.NioSocketChannel.doReadBytes(NioSocketChannel.java:372)
	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:123)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:624)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:559)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:476)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:438)
	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:858)
	at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:144)
	at java.lang.Thread.run(Thread.java:745)
[INFO ][20170413 23:25:13,010][TcpServer:56] Wenhua Mesage Tcp Server starting...
[INFO ][20170413 23:25:13,072][AbstractApplicationContext:582] Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@1be57c25: startup date [Thu Apr 13 23:25:13 CST 2017]; root of context hierarchy
[INFO ][20170413 23:25:13,130][XmlBeanDefinitionReader:317] Loading XML bean definitions from class path resource [spring-context.xml]
[INFO ][20170413 23:25:13,381][TcpServer:71] ##TcpServer begin start, port is [10089]
[INFO ][20170413 23:25:13,381][TcpServer:25] Server start at [10089]...
[INFO ][20170413 23:25:19,937][ChannelHandlerWenhuaMsgClient:19] MessageProto channelActive
[ERROR][20170413 23:25:34,547][ChannelHandlerWenhuaMsg:50] ##exceptionCaught
java.io.IOException: 远程主机强迫关闭了一个现有的连接。
	at sun.nio.ch.SocketDispatcher.read0(Native Method)
	at sun.nio.ch.SocketDispatcher.read(SocketDispatcher.java:43)
	at sun.nio.ch.IOUtil.readIntoNativeBuffer(IOUtil.java:223)
	at sun.nio.ch.IOUtil.read(IOUtil.java:192)
	at sun.nio.ch.SocketChannelImpl.read(SocketChannelImpl.java:384)
	at io.netty.buffer.PooledUnsafeDirectByteBuf.setBytes(PooledUnsafeDirectByteBuf.java:288)
	at io.netty.buffer.AbstractByteBuf.writeBytes(AbstractByteBuf.java:1100)
	at io.netty.channel.socket.nio.NioSocketChannel.doReadBytes(NioSocketChannel.java:372)
	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:123)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:624)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:559)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:476)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:438)
	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:858)
	at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:144)
	at java.lang.Thread.run(Thread.java:745)
[WARN ][20170413 23:25:34,552][Slf4JLogger:151] An exceptionCaught() event was fired, and it reached at the tail of the pipeline. It usually means the last handler in the pipeline did not handle the exception.
java.io.IOException: 远程主机强迫关闭了一个现有的连接。
	at sun.nio.ch.SocketDispatcher.read0(Native Method)
	at sun.nio.ch.SocketDispatcher.read(SocketDispatcher.java:43)
	at sun.nio.ch.IOUtil.readIntoNativeBuffer(IOUtil.java:223)
	at sun.nio.ch.IOUtil.read(IOUtil.java:192)
	at sun.nio.ch.SocketChannelImpl.read(SocketChannelImpl.java:384)
	at io.netty.buffer.PooledUnsafeDirectByteBuf.setBytes(PooledUnsafeDirectByteBuf.java:288)
	at io.netty.buffer.AbstractByteBuf.writeBytes(AbstractByteBuf.java:1100)
	at io.netty.channel.socket.nio.NioSocketChannel.doReadBytes(NioSocketChannel.java:372)
	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:123)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:624)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:559)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:476)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:438)
	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:858)
	at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:144)
	at java.lang.Thread.run(Thread.java:745)
[INFO ][20170413 23:26:06,703][TcpServer:56] Wenhua Mesage Tcp Server starting...
[INFO ][20170413 23:26:06,765][AbstractApplicationContext:582] Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@1be57c25: startup date [Thu Apr 13 23:26:06 CST 2017]; root of context hierarchy
[INFO ][20170413 23:26:06,824][XmlBeanDefinitionReader:317] Loading XML bean definitions from class path resource [spring-context.xml]
[INFO ][20170413 23:26:07,096][TcpServer:71] ##TcpServer begin start, port is [10089]
[INFO ][20170413 23:26:07,096][TcpServer:25] Server start at [10089]...
[INFO ][20170413 23:26:07,714][TcpServer:51] Server shutdown
[INFO ][20170413 23:26:15,729][TcpServer:56] Wenhua Mesage Tcp Server starting...
[INFO ][20170413 23:26:15,791][AbstractApplicationContext:582] Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@1be57c25: startup date [Thu Apr 13 23:26:15 CST 2017]; root of context hierarchy
[INFO ][20170413 23:26:15,848][XmlBeanDefinitionReader:317] Loading XML bean definitions from class path resource [spring-context.xml]
[INFO ][20170413 23:26:16,113][TcpServer:71] ##TcpServer begin start, port is [10089]
[INFO ][20170413 23:26:16,113][TcpServer:25] Server start at [10089]...
[INFO ][20170413 23:33:00,831][ChannelHandlerWenhuaMsgClient:19] MessageProto channelActive
[WARN ][20170413 23:33:16,802][Slf4JLogger:151] An exceptionCaught() event was fired, and it reached at the tail of the pipeline. It usually means the last handler in the pipeline did not handle the exception.
java.io.IOException: 远程主机强迫关闭了一个现有的连接。
	at sun.nio.ch.SocketDispatcher.read0(Native Method)
	at sun.nio.ch.SocketDispatcher.read(SocketDispatcher.java:43)
	at sun.nio.ch.IOUtil.readIntoNativeBuffer(IOUtil.java:223)
	at sun.nio.ch.IOUtil.read(IOUtil.java:192)
	at sun.nio.ch.SocketChannelImpl.read(SocketChannelImpl.java:384)
	at io.netty.buffer.PooledUnsafeDirectByteBuf.setBytes(PooledUnsafeDirectByteBuf.java:288)
	at io.netty.buffer.AbstractByteBuf.writeBytes(AbstractByteBuf.java:1100)
	at io.netty.channel.socket.nio.NioSocketChannel.doReadBytes(NioSocketChannel.java:372)
	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:123)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:624)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:559)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:476)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:438)
	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:858)
	at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:144)
	at java.lang.Thread.run(Thread.java:745)
[INFO ][20170413 23:33:31,855][TcpServer:56] Wenhua Mesage Tcp Server starting...
[INFO ][20170413 23:33:31,916][AbstractApplicationContext:582] Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@453130df: startup date [Thu Apr 13 23:33:31 CST 2017]; root of context hierarchy
[INFO ][20170413 23:33:31,972][XmlBeanDefinitionReader:317] Loading XML bean definitions from class path resource [spring-context.xml]
[INFO ][20170413 23:33:32,249][TcpServer:71] ##TcpServer begin start, port is [8080]
[INFO ][20170413 23:33:32,250][TcpServer:25] Server start at [8080]...
[INFO ][20170413 23:33:40,349][ChannelHandlerWenhuaMsgClient:19] MessageProto channelActive
[ERROR][20170413 23:33:43,329][ChannelHandlerWenhuaMsg:50] ##exceptionCaught
java.io.IOException: 远程主机强迫关闭了一个现有的连接。
	at sun.nio.ch.SocketDispatcher.read0(Native Method)
	at sun.nio.ch.SocketDispatcher.read(SocketDispatcher.java:43)
	at sun.nio.ch.IOUtil.readIntoNativeBuffer(IOUtil.java:223)
	at sun.nio.ch.IOUtil.read(IOUtil.java:192)
	at sun.nio.ch.SocketChannelImpl.read(SocketChannelImpl.java:384)
	at io.netty.buffer.PooledUnsafeDirectByteBuf.setBytes(PooledUnsafeDirectByteBuf.java:288)
	at io.netty.buffer.AbstractByteBuf.writeBytes(AbstractByteBuf.java:1100)
	at io.netty.channel.socket.nio.NioSocketChannel.doReadBytes(NioSocketChannel.java:372)
	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:123)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:624)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:559)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:476)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:438)
	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:858)
	at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:144)
	at java.lang.Thread.run(Thread.java:745)
[WARN ][20170413 23:33:43,332][Slf4JLogger:151] An exceptionCaught() event was fired, and it reached at the tail of the pipeline. It usually means the last handler in the pipeline did not handle the exception.
java.io.IOException: 远程主机强迫关闭了一个现有的连接。
	at sun.nio.ch.SocketDispatcher.read0(Native Method)
	at sun.nio.ch.SocketDispatcher.read(SocketDispatcher.java:43)
	at sun.nio.ch.IOUtil.readIntoNativeBuffer(IOUtil.java:223)
	at sun.nio.ch.IOUtil.read(IOUtil.java:192)
	at sun.nio.ch.SocketChannelImpl.read(SocketChannelImpl.java:384)
	at io.netty.buffer.PooledUnsafeDirectByteBuf.setBytes(PooledUnsafeDirectByteBuf.java:288)
	at io.netty.buffer.AbstractByteBuf.writeBytes(AbstractByteBuf.java:1100)
	at io.netty.channel.socket.nio.NioSocketChannel.doReadBytes(NioSocketChannel.java:372)
	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:123)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:624)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:559)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:476)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:438)
	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:858)
	at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:144)
	at java.lang.Thread.run(Thread.java:745)
[INFO ][20170413 23:35:48,104][TcpServer:56] Wenhua Mesage Tcp Server starting...
[INFO ][20170413 23:35:48,173][AbstractApplicationContext:582] Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@1be57c25: startup date [Thu Apr 13 23:35:48 CST 2017]; root of context hierarchy
[INFO ][20170413 23:35:48,240][XmlBeanDefinitionReader:317] Loading XML bean definitions from class path resource [spring-context.xml]
[INFO ][20170413 23:35:48,588][TcpServer:71] ##TcpServer begin start, port is [8080]
[INFO ][20170413 23:35:48,588][TcpServer:25] Server start at [8080]...
[INFO ][20170413 23:35:54,025][ChannelHandlerWenhuaMsgClient:19] MessageProto channelActive
[ERROR][20170413 23:35:59,377][ChannelHandlerWenhuaMsg:49] ##exceptionCaught
java.io.IOException: 远程主机强迫关闭了一个现有的连接。
	at sun.nio.ch.SocketDispatcher.read0(Native Method)
	at sun.nio.ch.SocketDispatcher.read(SocketDispatcher.java:43)
	at sun.nio.ch.IOUtil.readIntoNativeBuffer(IOUtil.java:223)
	at sun.nio.ch.IOUtil.read(IOUtil.java:192)
	at sun.nio.ch.SocketChannelImpl.read(SocketChannelImpl.java:384)
	at io.netty.buffer.PooledUnsafeDirectByteBuf.setBytes(PooledUnsafeDirectByteBuf.java:288)
	at io.netty.buffer.AbstractByteBuf.writeBytes(AbstractByteBuf.java:1100)
	at io.netty.channel.socket.nio.NioSocketChannel.doReadBytes(NioSocketChannel.java:372)
	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:123)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:624)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:559)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:476)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:438)
	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:858)
	at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:144)
	at java.lang.Thread.run(Thread.java:745)
[WARN ][20170413 23:35:59,379][Slf4JLogger:151] An exceptionCaught() event was fired, and it reached at the tail of the pipeline. It usually means the last handler in the pipeline did not handle the exception.
java.io.IOException: 远程主机强迫关闭了一个现有的连接。
	at sun.nio.ch.SocketDispatcher.read0(Native Method)
	at sun.nio.ch.SocketDispatcher.read(SocketDispatcher.java:43)
	at sun.nio.ch.IOUtil.readIntoNativeBuffer(IOUtil.java:223)
	at sun.nio.ch.IOUtil.read(IOUtil.java:192)
	at sun.nio.ch.SocketChannelImpl.read(SocketChannelImpl.java:384)
	at io.netty.buffer.PooledUnsafeDirectByteBuf.setBytes(PooledUnsafeDirectByteBuf.java:288)
	at io.netty.buffer.AbstractByteBuf.writeBytes(AbstractByteBuf.java:1100)
	at io.netty.channel.socket.nio.NioSocketChannel.doReadBytes(NioSocketChannel.java:372)
	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:123)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:624)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:559)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:476)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:438)
	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:858)
	at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:144)
	at java.lang.Thread.run(Thread.java:745)
[INFO ][20170413 23:40:13,177][TcpServer:80] Wenhua Mesage Tcp Server starting...
[INFO ][20170413 23:40:13,243][AbstractApplicationContext:582] Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@5bc3a0dd: startup date [Thu Apr 13 23:40:13 CST 2017]; root of context hierarchy
[INFO ][20170413 23:40:13,320][XmlBeanDefinitionReader:317] Loading XML bean definitions from class path resource [spring-context.xml]
[INFO ][20170413 23:40:13,588][TcpServer:95] ##TcpServer begin start, port is [8080]
[INFO ][20170413 23:40:13,589][TcpServer:32] Server start at [8080]...
[INFO ][20170413 23:40:20,023][ChannelHandlerWenhuaMsgClient:19] MessageProto channelActive
[ERROR][20170413 23:40:27,837][ChannelHandlerWenhuaMsg:49] ##exceptionCaught
java.io.IOException: 远程主机强迫关闭了一个现有的连接。
	at sun.nio.ch.SocketDispatcher.read0(Native Method)
	at sun.nio.ch.SocketDispatcher.read(SocketDispatcher.java:43)
	at sun.nio.ch.IOUtil.readIntoNativeBuffer(IOUtil.java:223)
	at sun.nio.ch.IOUtil.read(IOUtil.java:192)
	at sun.nio.ch.SocketChannelImpl.read(SocketChannelImpl.java:384)
	at io.netty.buffer.PooledUnsafeDirectByteBuf.setBytes(PooledUnsafeDirectByteBuf.java:288)
	at io.netty.buffer.AbstractByteBuf.writeBytes(AbstractByteBuf.java:1100)
	at io.netty.channel.socket.nio.NioSocketChannel.doReadBytes(NioSocketChannel.java:372)
	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:123)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:624)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:559)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:476)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:438)
	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:858)
	at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:144)
	at java.lang.Thread.run(Thread.java:745)
[WARN ][20170413 23:40:27,844][Slf4JLogger:151] An exceptionCaught() event was fired, and it reached at the tail of the pipeline. It usually means the last handler in the pipeline did not handle the exception.
java.io.IOException: 远程主机强迫关闭了一个现有的连接。
	at sun.nio.ch.SocketDispatcher.read0(Native Method)
	at sun.nio.ch.SocketDispatcher.read(SocketDispatcher.java:43)
	at sun.nio.ch.IOUtil.readIntoNativeBuffer(IOUtil.java:223)
	at sun.nio.ch.IOUtil.read(IOUtil.java:192)
	at sun.nio.ch.SocketChannelImpl.read(SocketChannelImpl.java:384)
	at io.netty.buffer.PooledUnsafeDirectByteBuf.setBytes(PooledUnsafeDirectByteBuf.java:288)
	at io.netty.buffer.AbstractByteBuf.writeBytes(AbstractByteBuf.java:1100)
	at io.netty.channel.socket.nio.NioSocketChannel.doReadBytes(NioSocketChannel.java:372)
	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:123)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:624)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:559)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:476)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:438)
	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:858)
	at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:144)
	at java.lang.Thread.run(Thread.java:745)
[INFO ][20170413 23:43:28,279][TcpServer:80] Wenhua Mesage Tcp Server starting...
[INFO ][20170413 23:43:28,342][AbstractApplicationContext:582] Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@5bc3a0dd: startup date [Thu Apr 13 23:43:28 CST 2017]; root of context hierarchy
[INFO ][20170413 23:43:28,400][XmlBeanDefinitionReader:317] Loading XML bean definitions from class path resource [spring-context.xml]
[INFO ][20170413 23:43:28,663][TcpServer:95] ##TcpServer begin start, port is [8080]
[INFO ][20170413 23:43:28,663][TcpServer:32] Server start at [8080]...
[INFO ][20170413 23:43:54,213][ChannelHandlerWenhuaMsgClient:19] MessageProto channelActive
[INFO ][20170413 23:43:54,250][ChannelHandlerWenhuaMsg:18] ##Active
[INFO ][20170413 23:43:54,286][ChannelHandlerWenhuaMsg:25] ##read
[INFO ][20170413 23:43:54,289][ChannelHandlerWenhuaMsg:27] Id[1492098234223] Method[auth] Content[<ByteString@782d8a2f size=5>] ReturnCode[0] ReturnMsg[OK]
[INFO ][20170413 23:43:54,289][ChannelHandlerWenhuaMsg:42] ##readComplete
[WARN ][20170413 23:44:45,693][Slf4JLogger:151] An exceptionCaught() event was fired, and it reached at the tail of the pipeline. It usually means the last handler in the pipeline did not handle the exception.
java.io.IOException: 远程主机强迫关闭了一个现有的连接。
	at sun.nio.ch.SocketDispatcher.read0(Native Method)
	at sun.nio.ch.SocketDispatcher.read(SocketDispatcher.java:43)
	at sun.nio.ch.IOUtil.readIntoNativeBuffer(IOUtil.java:223)
	at sun.nio.ch.IOUtil.read(IOUtil.java:192)
	at sun.nio.ch.SocketChannelImpl.read(SocketChannelImpl.java:384)
	at io.netty.buffer.PooledUnsafeDirectByteBuf.setBytes(PooledUnsafeDirectByteBuf.java:288)
	at io.netty.buffer.AbstractByteBuf.writeBytes(AbstractByteBuf.java:1100)
	at io.netty.channel.socket.nio.NioSocketChannel.doReadBytes(NioSocketChannel.java:372)
	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:123)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:624)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:559)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:476)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:438)
	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:858)
	at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:144)
	at java.lang.Thread.run(Thread.java:745)
[INFO ][20170413 23:47:46,968][TcpServer:56] Wenhua Mesage Tcp Server starting...
[INFO ][20170413 23:47:47,036][AbstractApplicationContext:582] Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@453130df: startup date [Thu Apr 13 23:47:47 CST 2017]; root of context hierarchy
[INFO ][20170413 23:47:47,099][XmlBeanDefinitionReader:317] Loading XML bean definitions from class path resource [spring-context.xml]
[WARN ][20170413 23:47:47,426][AbstractApplicationContext:550] Exception encountered during context initialization - cancelling refresh attempt: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'tcpServer' defined in class path resource [spring-context.xml]: Cannot resolve reference to bean 'tcpServerInitializer' while setting bean property 'initializer'; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'tcpServerInitializer' defined in class path resource [spring-context.xml]: Error setting property values; nested exception is org.springframework.beans.NotWritablePropertyException: Invalid property 'handler' of bean class [com.wenhua.server.TcpServerInitializer]: Bean property 'handler' is not writable or has an invalid setter method. Does the parameter type of the setter match the return type of the getter?
[INFO ][20170413 23:48:11,455][TcpServer:56] Wenhua Mesage Tcp Server starting...
[INFO ][20170413 23:48:11,515][AbstractApplicationContext:582] Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@207fa3f6: startup date [Thu Apr 13 23:48:11 CST 2017]; root of context hierarchy
[INFO ][20170413 23:48:11,573][XmlBeanDefinitionReader:317] Loading XML bean definitions from class path resource [spring-context.xml]
[INFO ][20170413 23:48:11,812][TcpServer:71] ##TcpServer begin start, port is [8080]
[INFO ][20170413 23:48:11,812][TcpServer:25] Server start at [8080]...
[INFO ][20170413 23:48:19,088][ChannelHandlerWenhuaMsgClient:19] MessageProto channelActive
[INFO ][20170413 23:48:19,125][ChannelHandlerWenhuaMsg:17] ##Active
[INFO ][20170413 23:48:19,164][ChannelHandlerWenhuaMsg:24] ##read
[INFO ][20170413 23:48:19,166][ChannelHandlerWenhuaMsg:26] Id[1492098499097] Method[auth] Content[<ByteString@46c366ac size=5>] ReturnCode[0] ReturnMsg[OK]
[INFO ][20170413 23:48:19,166][ChannelHandlerWenhuaMsg:41] ##readComplete
[WARN ][20170413 23:48:26,443][Slf4JLogger:151] An exceptionCaught() event was fired, and it reached at the tail of the pipeline. It usually means the last handler in the pipeline did not handle the exception.
java.io.IOException: 远程主机强迫关闭了一个现有的连接。
	at sun.nio.ch.SocketDispatcher.read0(Native Method)
	at sun.nio.ch.SocketDispatcher.read(SocketDispatcher.java:43)
	at sun.nio.ch.IOUtil.readIntoNativeBuffer(IOUtil.java:223)
	at sun.nio.ch.IOUtil.read(IOUtil.java:192)
	at sun.nio.ch.SocketChannelImpl.read(SocketChannelImpl.java:384)
	at io.netty.buffer.PooledUnsafeDirectByteBuf.setBytes(PooledUnsafeDirectByteBuf.java:288)
	at io.netty.buffer.AbstractByteBuf.writeBytes(AbstractByteBuf.java:1100)
	at io.netty.channel.socket.nio.NioSocketChannel.doReadBytes(NioSocketChannel.java:372)
	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:123)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:624)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:559)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:476)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:438)
	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:858)
	at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:144)
	at java.lang.Thread.run(Thread.java:745)
[INFO ][20170413 23:56:09,784][TcpServer:56] Wenhua Mesage Tcp Server starting...
[INFO ][20170413 23:56:09,845][AbstractApplicationContext:582] Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@453130df: startup date [Thu Apr 13 23:56:09 CST 2017]; root of context hierarchy
[INFO ][20170413 23:56:09,904][XmlBeanDefinitionReader:317] Loading XML bean definitions from class path resource [spring-context.xml]
[INFO ][20170413 23:56:10,170][TcpServer:71] ##TcpServer begin start, port is [8080]
[INFO ][20170413 23:56:10,170][TcpServer:25] Server start at [8080]...
[INFO ][20170413 23:56:17,676][ChannelHandlerWenhuaMsgClient:19] MessageProto channelActive
[INFO ][20170413 23:56:17,710][ChannelHandlerWenhuaMsg:20] ##Active
[INFO ][20170413 23:56:17,749][ChannelHandlerWenhuaMsg:27] ##read
[INFO ][20170413 23:56:17,752][ChannelHandlerWenhuaMsg:37] Id[1492098977686] Method[auth] Content[<ByteString@2482448a size=5>] ReturnCode[0] ReturnMsg[OK]
[INFO ][20170413 23:56:17,770][ChannelHandlerWenhuaMsg:56] ##readComplete
[INFO ][20170413 23:56:17,777][ChannelHandlerWenhuaMsgClient:31] ##read
[INFO ][20170413 23:56:17,778][ChannelHandlerWenhuaMsgClient:41] Id[1492098977686] Method[auth] Content[<ByteString@6f54173f size=96>] ReturnCode[0] ReturnMsg[OK]
[INFO ][20170413 23:56:46,222][ChannelHandlerWenhuaMsg:56] ##readComplete
[ERROR][20170413 23:56:46,225][ChannelHandlerWenhuaMsg:63] ##exceptionCaught
java.io.IOException: 远程主机强迫关闭了一个现有的连接。
	at sun.nio.ch.SocketDispatcher.read0(Native Method)
	at sun.nio.ch.SocketDispatcher.read(SocketDispatcher.java:43)
	at sun.nio.ch.IOUtil.readIntoNativeBuffer(IOUtil.java:223)
	at sun.nio.ch.IOUtil.read(IOUtil.java:192)
	at sun.nio.ch.SocketChannelImpl.read(SocketChannelImpl.java:384)
	at io.netty.buffer.PooledUnsafeDirectByteBuf.setBytes(PooledUnsafeDirectByteBuf.java:288)
	at io.netty.buffer.AbstractByteBuf.writeBytes(AbstractByteBuf.java:1100)
	at io.netty.channel.socket.nio.NioSocketChannel.doReadBytes(NioSocketChannel.java:372)
	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:123)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:624)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:559)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:476)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:438)
	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:858)
	at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:144)
	at java.lang.Thread.run(Thread.java:745)
[WARN ][20170413 23:56:46,232][Slf4JLogger:151] An exceptionCaught() event was fired, and it reached at the tail of the pipeline. It usually means the last handler in the pipeline did not handle the exception.
java.io.IOException: 远程主机强迫关闭了一个现有的连接。
	at sun.nio.ch.SocketDispatcher.read0(Native Method)
	at sun.nio.ch.SocketDispatcher.read(SocketDispatcher.java:43)
	at sun.nio.ch.IOUtil.readIntoNativeBuffer(IOUtil.java:223)
	at sun.nio.ch.IOUtil.read(IOUtil.java:192)
	at sun.nio.ch.SocketChannelImpl.read(SocketChannelImpl.java:384)
	at io.netty.buffer.PooledUnsafeDirectByteBuf.setBytes(PooledUnsafeDirectByteBuf.java:288)
	at io.netty.buffer.AbstractByteBuf.writeBytes(AbstractByteBuf.java:1100)
	at io.netty.channel.socket.nio.NioSocketChannel.doReadBytes(NioSocketChannel.java:372)
	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:123)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:624)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:559)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:476)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:438)
	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:858)
	at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:144)
	at java.lang.Thread.run(Thread.java:745)
